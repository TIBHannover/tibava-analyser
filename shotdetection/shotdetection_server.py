import base64
from concurrent import futures
import grpc
import imageio
import logging
import os
from skimage.transform import resize
import traceback
from transnetv2 import TransNetV2
import yaml

import shotdetection_pb2  # autogenerated file from grpc
import shotdetection_pb2_grpc  # autogenerated file from grpc

# read config
_CUR_PATH = os.path.dirname(__file__)
with open(os.path.join(_CUR_PATH, "config.yml")) as f:
    _CFG = yaml.load(f, Loader=yaml.FullLoader)

# init logging
logging.basicConfig(format="%(asctime)s %(levelname)s:%(message)s", datefmt="%Y-%m-%d %H:%M:%S", level=logging.INFO)


class ShotDetector(shotdetection_pb2_grpc.ShotDetectorServicer):
    def __init__(self, max_thumbnail_size=384):
        # initialize TransNetV2
        self.shotDetector = TransNetV2(_CFG["model_path"])
        self._max_thumbnail_size = max_thumbnail_size

        # setup media directory
        if not os.path.exists(_CFG["media_folder"]):
            os.makedirs(os.path.join(_CUR_PATH, _CFG["media_folder"]))

    def copy_video(self, request_iterator, context):
        try:
            # save video from request input stream
            datastream = iter(request_iterator)
            firstpkg = next(datastream)
            video_id = firstpkg.video_id

            with open(os.path.join(_CFG["media_folder"], video_id + ".mp4"), "wb") as videofile:
                videofile.write(firstpkg.video_encoded)  # write first package
                for data in datastream:
                    videofile.write(data.video_encoded)

            return shotdetection_pb2.VideoResponse(success=True)

        except Exception as e:
            logging.error(f"copy_video: {repr(e)}")
            logging.error(traceback.format_exc())
            # context.set_code(grpc.StatusCode.UNAVAILABLE)
            # context.set_details(f"Error transferring video with id {req.video_id}")

        return shotdetection_pb2.VideoResponse(success=False)

    def get_shots(self, request, context):
        # create video path from video id
        video_path = os.path.join(_CFG["media_folder"], request.video_id + ".mp4")

        try:
            # get video shots
            _, single_frame_predictions, _ = self.shotDetector.predict_video(video_path)

            # write results
            shots = list(self.shotDetector.predictions_to_scenes(single_frame_predictions))
            shot_dict = []

            for shot_id, shot in enumerate(shots):
                shot_dict.append(
                    shotdetection_pb2.Shot(
                        shot_id=int(shot_id),
                        start_frame=int(shot[0]),
                        end_frame=int(shot[1]),
                    )
                )

            return shotdetection_pb2.ShotResponse(success=True, shots=shot_dict)

        except Exception as e:
            logging.error(f"get_shots: {repr(e)}")
            logging.error(traceback.format_exc())
            # context.set_code(grpc.StatusCode.UNAVAILABLE)
            # context.set_details(f"Error finding shots in video with id {request.video_id}")

        return shotdetection_pb2.ShotResponse(success=False, shots=[])


def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    shotdetection_pb2_grpc.add_ShotDetectorServicer_to_server(ShotDetector(), server)
    server.add_insecure_port("[::]:" + str(_CFG["grpc_port"]))
    server.start()
    print(f"Server is running {'[::]:' + str(_CFG['grpc_port'])}")
    server.wait_for_termination()


if __name__ == "__main__":
    logging.basicConfig()
    serve()
